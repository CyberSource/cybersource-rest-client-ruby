=begin
#CyberSource Merged Spec

#All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html

OpenAPI spec version: 0.0.1

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.2.3

=end

require 'date'

module CyberSource
  class PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation
    # Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK. 
    attr_accessor :acs_rendering_type

    # Unique transaction identifier assigned by the ACS to identify a single transaction. 
    attr_accessor :acs_transaction_id

    # URL for the card-issuing bank’s authentication form that you receive when the card is enrolled. The value can be very large. 
    attr_accessor :acs_url

    # Indicates what displays to the customer during the authentication process. This field can contain one of these values: - `ADS`: (Card not enrolled) customer prompted to activate the card during the checkout process. - `ATTEMPTS`: (Attempts processing) Processing briefly displays before the checkout process is completed. - `ENROLLED`: (Card enrolled) the card issuer’s authentication window displays. - `UNKNOWN`: Card enrollment status cannot be determined. - `NOREDIRECT`: (Card not enrolled, authentication unavailable, or error occurred) nothing displays to the customer.  The following values can be returned if you are using rules-based payer authentication. - `RIBA`: The card-issuing bank supports risk-based authentication, but whether the cardholder is likely to be challenged cannot be determined. - `RIBA_PASS`: The card-issuing bank supports risk-based authentication and it is likely that the cardholder will not be challenged to provide credentials, also known as _silent authentication_.  For details about possible values, see `pa_enroll_authentication_path` field description and \"Rules-Based Payer Authentication\" in [CyberSource Payer Authentication Using the SCMP API.] (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/) 
    attr_accessor :authentication_path

    # The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow 
    attr_accessor :authorization_payload

    # Payer authentication transaction identifier passed to link the check enrollment and validate authentication messages. 
    attr_accessor :authentication_transaction_id

    # Text provided by the ACS/Issuer to Cardholder during a Frictionless or Decoupled transaction.The Issuer can provide information to Cardholder. For example, “Additional authentication is needed for this transaction, please contact (Issuer Name) at xxx-xxx-xxxx.”. The Issuing Bank can optionally support this value. 
    attr_accessor :cardholder_message

    # Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and Discover transactions after the customer is authenticated. The value is in base64. When you request the card authorization service, CyberSource automatically converts the value, not the field name, to the format required by your payment processor. 
    attr_accessor :cavv

    # Field that is returned only when the CAVV is generated, which occurs when paresStatus contains the values Y (successful authentication) or A (attempted authentication). If you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the authorization service. This field contains one of these values: - `2`: Visa, American Express, JCB, Diners Club, and Discover - `3`: Mastercard 
    attr_accessor :cavv_algorithm

    # An indicator as to why the transaction was canceled. Possible Values:  - `01`: Cardholder selected Cancel. - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo). - `03`: Transaction Timed Out—Decoupled Authentication - `04`: Transaction timed out at ACS—other timeouts - `05`: Transaction Timed out at ACS - First CReq not received by ACS - `06`: Transaction Error - `07`: Unknown - `08`: Transaction Timed Out at SDK 
    attr_accessor :challenge_cancel_code

    # Indicates whether a challenge is required in order to complete authentication. **Note** Regional mandates might determine that a challenge is required.  Possible values: - `Y`: Challenge required - `N`: Challenge not required **Note**  Used by the Hybrid integration. 
    attr_accessor :challenge_required

    # Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.  Possible Values:  Y - Decoupled Authentication is supported and preferred if challenge is necessary  N - Do not use Decoupled Authentication  **Default Value**: N 
    attr_accessor :decoupled_authentication_indicator

    # The directory server error code indicating a problem with this transaction. Note - Max Length of this field is typically 3 characters. 
    attr_accessor :directory_server_error_code

    # Directory server text and additional detail about the error for this transaction. 
    attr_accessor :directory_server_error_description

    # Commerce indicator for cards not enrolled. This field contains one of these values: - `internet`: Card not enrolled, or card type not supported by payer authentication. No liability shift. - `js_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift. - `js_failure`: J/Secure directory service is not available. No liability shift. - `spa`: Mastercard card not enrolled in the SecureCode program. No liability shift. - `vbv_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift. - `vbv_failure`: For payment processor Barclays, Streamline, AIBMS, or FDC Germany, you receive this result if Visa’s directory service is not available. No liability shift. 
    attr_accessor :ecommerce_indicator

    # Note This field applies only to non-U.S-issued cards.  For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions when the card is not enrolled. For more information, see \"Interpreting the Reply,\" page 22.  If you are not using the CyberSource payment services, you must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `06`: The card can be enrolled. Liability shift. - `07`: The card cannot be enrolled. No liability shift.  For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions. The field is absent when authentication fails. You must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `05`: Successful authentication - `06`: Authentication attempted - `07`: Failed authentication (No response from the merchant because of a problem.) 
    attr_accessor :eci

    # ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover. The field is absent when authentication fails. If your payment processor is Streamline, you must pass the value of this field instead of the value of `eci` or `ucafCollectionIndicator`.  This field can contain one of these values: - `01`: Authentication attempted (Mastercard) - `02`: Successful authentication (Mastercard) - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover) - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover) 
    attr_accessor :eci_raw

    # This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows; CH - Challenge FR - Frictionless FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer). 
    attr_accessor :effective_authentication_type

    attr_accessor :ivr

    # The global score calculated by the CB scoring platform and returned to merchants. 
    attr_accessor :network_score

    # Payer authentication request (PAReq) message that you need to forward to the ACS. The value can be very large. The value is in base64. 
    attr_accessor :pareq

    # Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway Processing, you need to send the value of this field in your authorization request. This field can contain one of these values: - `A`: Proof of authentication attempt was generated. - `N`: Customer failed or canceled authentication. Transaction denied. - `U`: Authentication not completed regardless of the reason. - `Y`: Customer was successfully authenticated. 
    attr_accessor :pares_status

    # Date and time of the enrollment check combined with the VEReq and VERes elements. If you ever need to show proof of enrollment checking, you may need to parse the string for the information required by the payment card company. The value can be very large. For details about possible values, see the `pa_enroll_proofxml` field description in [CyberSource Payer Authentication Using the SCMP API.] (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/) - For cards issued in the U.S. or Canada, Visa may require this data for specific merchant category codes. - For cards not issued in the U.S. or Canada, your bank may require this data as proof of enrollment checking for any payer authentication transaction that you re-present because of a chargeback. 
    attr_accessor :proof_xml

    # Encrypted version of the card number used in the payer authentication request message. 
    attr_accessor :proxy_pan

    # SDK unique transaction identifier that is generated on each new transaction. 
    attr_accessor :sdk_transaction_id

    # Provides additional information as to why the PAResStatus has a specific value. 
    attr_accessor :signed_pares_status_reason

    # This field contains the 3D Secure version that was used to process the transaction. For example, 1.0.2 or 2.0.0. 
    attr_accessor :specification_version

    # The fully qualified URL that the merchant uses to post a form to the cardholder in order to complete the Consumer Authentication transaction for the Cardinal Cruise API integration. 
    attr_accessor :step_up_url

    # Unique transaction identifier assigned by the 3DS Server to identify a single transaction. 
    attr_accessor :three_ds_server_transaction_id

    # AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check transactions after the customer is authenticated. The value is in base64. Include the data in the card authorization request. 
    attr_accessor :ucaf_authentication_data

    # For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator. This field can contain these values: 0, 1.  For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check transactions. The field is absent when authentication fails. You must send this value to your payment processor in the request for card authorization. This field contain one of these values: - `0`: Authentication data not collected, and customer authentication was not completed. - `1`: Authentication data not collected because customer authentication was not completed. - `2`: Authentication data collected because customer completed authentication. 
    attr_accessor :ucaf_collection_indicator

    # Result of the enrollment check. This field can contain one of these values: - `Y`: Card enrolled or can be enrolled; you must authenticate. Liability shift. - `N`: Card not enrolled; proceed with authorization. Liability shift. - `U`: Unable to authenticate regardless of the reason. No liability shift.  **Note** This field only applies to the Asia, Middle East, and Africa Gateway. If you are configured for this processor, you must send the value of this field in your authorization request.  The following value can be returned if you are using rules-based Payer Authentication: - `B`: Indicates that authentication was bypassed.  For details, see `pa_enroll_veres_enrolled` field description in [CyberSource Payer Authentication Using the SCMP API.] (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/) 
    attr_accessor :veres_enrolled

    # This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02 – DS/03 - ACS 
    attr_accessor :white_list_status_source

    # Transaction identifier generated by CyberSource for successful enrollment or validation checks. Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes. CyberSource forwards the XID with the card authorization service to these payment processors in these cases: - Barclays - Streamline (when the **ecommerceIndicator**`=spa`) 
    attr_accessor :xid

    # The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results. For Cybersource Through Visanet Gateway: The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID 
    attr_accessor :directory_server_transaction_id

    # Raw authentication data that comes from the cardissuing bank. Primary authentication field that indicates if authentication was successful and if liability shift occurred. You should examine first the result of this field. This field contains one of these values: - `-1`: Invalid PARes. - `0`: Successful validation. - `1`: Cardholder is not participating, but the attempt to authenticate was recorded. - `6`: Issuer unable to perform authentication. - `9`: Cardholder did not complete authentication. 
    attr_accessor :authentication_result

    # Message that explains the authenticationResult reply field. 
    attr_accessor :authentication_status_msg

    # Indicator used to differentiate Internet transactions from other types. The authentication failed if this field is not returned. For Visa, if your payment processor is Streamline, Barclays, AIBMS, or FDC Germany, you receive the value vbv_failure instead of internet when eci is 07. The value of this field is passed automatically to the authorization service if you request the services together. This field contains one of these values: - `aesk`: American Express SafeKey authentication verified successfully. - `aesk_attempted`: Card not enrolled in American Express SafeKey, but the attempt to authenticate was recorded. - `dipb`: Discover ProtectBuy authentication verified successfully. - `dipb_attempted`: Card not enrolled in Discover ProtectBuy, but the attempt to authenticate was recorded. - `internet`: Authentication was not verified successfully. - `js`: J/Secure authentication verified successfully. - `js_attempted`: Card not enrolled in J/Secure, but the attempt to authenticate was recorded. - `moto`: Mail or telephone order. - `pb_attempted`: Card not enrolled in Diners Club ProtectBuy, but the attempt to authenticate was recorded. - `recurring`: Recurring transaction. - `spa`: Mastercard Identity Check authentication verified successfully. - `spa_failure`: Mastercard Identity Check failed authentication. - `vbv`: Visa Secure authentication verified successfully. - `vbv_attempted`: Card not enrolled in Visa Secure, but the attempt to authenticate was recorded. - `vbv_failure`: Visa Secure authentication unavailable. 
    attr_accessor :indicator

    # Indicates the number of authentication cycles attempted by the cardholder and is tracked by the Issuing Banks ACS.Example: if customer gets the challenge window and enter in their one time password and hit submit then that interaction counter should just be 1. When customer gets the challenge window and the bank asks if they want to have the one time password  sent to their phone or their email and they have to choose before going to the next screen to enter in their one time password then this interaction count would be 2. One for the selection of how they want the one time password delivered and another with them actually entering in the one time password and hitting the submit button. 
    attr_accessor :interaction_counter

    # Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.  Possible Values:  Y - 3DS Requestor is whitelisted by cardholder  N - 3DS Requestor is not whitelisted by cardholder 
    attr_accessor :white_list_status

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'acs_rendering_type' => :'acsRenderingType',
        :'acs_transaction_id' => :'acsTransactionId',
        :'acs_url' => :'acsUrl',
        :'authentication_path' => :'authenticationPath',
        :'authorization_payload' => :'authorizationPayload',
        :'authentication_transaction_id' => :'authenticationTransactionId',
        :'cardholder_message' => :'cardholderMessage',
        :'cavv' => :'cavv',
        :'cavv_algorithm' => :'cavvAlgorithm',
        :'challenge_cancel_code' => :'challengeCancelCode',
        :'challenge_required' => :'challengeRequired',
        :'decoupled_authentication_indicator' => :'decoupledAuthenticationIndicator',
        :'directory_server_error_code' => :'directoryServerErrorCode',
        :'directory_server_error_description' => :'directoryServerErrorDescription',
        :'ecommerce_indicator' => :'ecommerceIndicator',
        :'eci' => :'eci',
        :'eci_raw' => :'eciRaw',
        :'effective_authentication_type' => :'effectiveAuthenticationType',
        :'ivr' => :'ivr',
        :'network_score' => :'networkScore',
        :'pareq' => :'pareq',
        :'pares_status' => :'paresStatus',
        :'proof_xml' => :'proofXml',
        :'proxy_pan' => :'proxyPan',
        :'sdk_transaction_id' => :'sdkTransactionId',
        :'signed_pares_status_reason' => :'signedParesStatusReason',
        :'specification_version' => :'specificationVersion',
        :'step_up_url' => :'stepUpUrl',
        :'three_ds_server_transaction_id' => :'threeDSServerTransactionId',
        :'ucaf_authentication_data' => :'ucafAuthenticationData',
        :'ucaf_collection_indicator' => :'ucafCollectionIndicator',
        :'veres_enrolled' => :'veresEnrolled',
        :'white_list_status_source' => :'whiteListStatusSource',
        :'xid' => :'xid',
        :'directory_server_transaction_id' => :'directoryServerTransactionId',
        :'authentication_result' => :'authenticationResult',
        :'authentication_status_msg' => :'authenticationStatusMsg',
        :'indicator' => :'indicator',
        :'interaction_counter' => :'interactionCounter',
        :'white_list_status' => :'whiteListStatus'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'acs_rendering_type' => :'String',
        :'acs_transaction_id' => :'String',
        :'acs_url' => :'String',
        :'authentication_path' => :'String',
        :'authorization_payload' => :'String',
        :'authentication_transaction_id' => :'String',
        :'cardholder_message' => :'String',
        :'cavv' => :'String',
        :'cavv_algorithm' => :'String',
        :'challenge_cancel_code' => :'String',
        :'challenge_required' => :'String',
        :'decoupled_authentication_indicator' => :'String',
        :'directory_server_error_code' => :'String',
        :'directory_server_error_description' => :'String',
        :'ecommerce_indicator' => :'String',
        :'eci' => :'String',
        :'eci_raw' => :'String',
        :'effective_authentication_type' => :'String',
        :'ivr' => :'PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr',
        :'network_score' => :'String',
        :'pareq' => :'String',
        :'pares_status' => :'String',
        :'proof_xml' => :'String',
        :'proxy_pan' => :'String',
        :'sdk_transaction_id' => :'String',
        :'signed_pares_status_reason' => :'String',
        :'specification_version' => :'String',
        :'step_up_url' => :'String',
        :'three_ds_server_transaction_id' => :'String',
        :'ucaf_authentication_data' => :'String',
        :'ucaf_collection_indicator' => :'String',
        :'veres_enrolled' => :'String',
        :'white_list_status_source' => :'String',
        :'xid' => :'String',
        :'directory_server_transaction_id' => :'String',
        :'authentication_result' => :'String',
        :'authentication_status_msg' => :'String',
        :'indicator' => :'String',
        :'interaction_counter' => :'String',
        :'white_list_status' => :'String'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'acsRenderingType')
        self.acs_rendering_type = attributes[:'acsRenderingType']
      end

      if attributes.has_key?(:'acsTransactionId')
        self.acs_transaction_id = attributes[:'acsTransactionId']
      end

      if attributes.has_key?(:'acsUrl')
        self.acs_url = attributes[:'acsUrl']
      end

      if attributes.has_key?(:'authenticationPath')
        self.authentication_path = attributes[:'authenticationPath']
      end

      if attributes.has_key?(:'authorizationPayload')
        self.authorization_payload = attributes[:'authorizationPayload']
      end

      if attributes.has_key?(:'authenticationTransactionId')
        self.authentication_transaction_id = attributes[:'authenticationTransactionId']
      end

      if attributes.has_key?(:'cardholderMessage')
        self.cardholder_message = attributes[:'cardholderMessage']
      end

      if attributes.has_key?(:'cavv')
        self.cavv = attributes[:'cavv']
      end

      if attributes.has_key?(:'cavvAlgorithm')
        self.cavv_algorithm = attributes[:'cavvAlgorithm']
      end

      if attributes.has_key?(:'challengeCancelCode')
        self.challenge_cancel_code = attributes[:'challengeCancelCode']
      end

      if attributes.has_key?(:'challengeRequired')
        self.challenge_required = attributes[:'challengeRequired']
      end

      if attributes.has_key?(:'decoupledAuthenticationIndicator')
        self.decoupled_authentication_indicator = attributes[:'decoupledAuthenticationIndicator']
      end

      if attributes.has_key?(:'directoryServerErrorCode')
        self.directory_server_error_code = attributes[:'directoryServerErrorCode']
      end

      if attributes.has_key?(:'directoryServerErrorDescription')
        self.directory_server_error_description = attributes[:'directoryServerErrorDescription']
      end

      if attributes.has_key?(:'ecommerceIndicator')
        self.ecommerce_indicator = attributes[:'ecommerceIndicator']
      end

      if attributes.has_key?(:'eci')
        self.eci = attributes[:'eci']
      end

      if attributes.has_key?(:'eciRaw')
        self.eci_raw = attributes[:'eciRaw']
      end

      if attributes.has_key?(:'effectiveAuthenticationType')
        self.effective_authentication_type = attributes[:'effectiveAuthenticationType']
      end

      if attributes.has_key?(:'ivr')
        self.ivr = attributes[:'ivr']
      end

      if attributes.has_key?(:'networkScore')
        self.network_score = attributes[:'networkScore']
      end

      if attributes.has_key?(:'pareq')
        self.pareq = attributes[:'pareq']
      end

      if attributes.has_key?(:'paresStatus')
        self.pares_status = attributes[:'paresStatus']
      end

      if attributes.has_key?(:'proofXml')
        self.proof_xml = attributes[:'proofXml']
      end

      if attributes.has_key?(:'proxyPan')
        self.proxy_pan = attributes[:'proxyPan']
      end

      if attributes.has_key?(:'sdkTransactionId')
        self.sdk_transaction_id = attributes[:'sdkTransactionId']
      end

      if attributes.has_key?(:'signedParesStatusReason')
        self.signed_pares_status_reason = attributes[:'signedParesStatusReason']
      end

      if attributes.has_key?(:'specificationVersion')
        self.specification_version = attributes[:'specificationVersion']
      end

      if attributes.has_key?(:'stepUpUrl')
        self.step_up_url = attributes[:'stepUpUrl']
      end

      if attributes.has_key?(:'threeDSServerTransactionId')
        self.three_ds_server_transaction_id = attributes[:'threeDSServerTransactionId']
      end

      if attributes.has_key?(:'ucafAuthenticationData')
        self.ucaf_authentication_data = attributes[:'ucafAuthenticationData']
      end

      if attributes.has_key?(:'ucafCollectionIndicator')
        self.ucaf_collection_indicator = attributes[:'ucafCollectionIndicator']
      end

      if attributes.has_key?(:'veresEnrolled')
        self.veres_enrolled = attributes[:'veresEnrolled']
      end

      if attributes.has_key?(:'whiteListStatusSource')
        self.white_list_status_source = attributes[:'whiteListStatusSource']
      end

      if attributes.has_key?(:'xid')
        self.xid = attributes[:'xid']
      end

      if attributes.has_key?(:'directoryServerTransactionId')
        self.directory_server_transaction_id = attributes[:'directoryServerTransactionId']
      end

      if attributes.has_key?(:'authenticationResult')
        self.authentication_result = attributes[:'authenticationResult']
      end

      if attributes.has_key?(:'authenticationStatusMsg')
        self.authentication_status_msg = attributes[:'authenticationStatusMsg']
      end

      if attributes.has_key?(:'indicator')
        self.indicator = attributes[:'indicator']
      end

      if attributes.has_key?(:'interactionCounter')
        self.interaction_counter = attributes[:'interactionCounter']
      end

      if attributes.has_key?(:'whiteListStatus')
        self.white_list_status = attributes[:'whiteListStatus']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@acs_transaction_id.nil? && @acs_transaction_id.to_s.length > 36
        invalid_properties.push('invalid value for "acs_transaction_id", the character length must be smaller than or equal to 36.')
      end

      if !@acs_url.nil? && @acs_url.to_s.length > 2048
        invalid_properties.push('invalid value for "acs_url", the character length must be smaller than or equal to 2048.')
      end

      if !@authentication_transaction_id.nil? && @authentication_transaction_id.to_s.length > 20
        invalid_properties.push('invalid value for "authentication_transaction_id", the character length must be smaller than or equal to 20.')
      end

      if !@cardholder_message.nil? && @cardholder_message.to_s.length > 128
        invalid_properties.push('invalid value for "cardholder_message", the character length must be smaller than or equal to 128.')
      end

      if !@cavv.nil? && @cavv.to_s.length > 255
        invalid_properties.push('invalid value for "cavv", the character length must be smaller than or equal to 255.')
      end

      if !@cavv_algorithm.nil? && @cavv_algorithm.to_s.length > 1
        invalid_properties.push('invalid value for "cavv_algorithm", the character length must be smaller than or equal to 1.')
      end

      if !@challenge_cancel_code.nil? && @challenge_cancel_code.to_s.length > 2
        invalid_properties.push('invalid value for "challenge_cancel_code", the character length must be smaller than or equal to 2.')
      end

      if !@challenge_required.nil? && @challenge_required.to_s.length > 1
        invalid_properties.push('invalid value for "challenge_required", the character length must be smaller than or equal to 1.')
      end

      if !@decoupled_authentication_indicator.nil? && @decoupled_authentication_indicator.to_s.length > 1
        invalid_properties.push('invalid value for "decoupled_authentication_indicator", the character length must be smaller than or equal to 1.')
      end

      if !@directory_server_error_description.nil? && @directory_server_error_description.to_s.length > 4096
        invalid_properties.push('invalid value for "directory_server_error_description", the character length must be smaller than or equal to 4096.')
      end

      if !@ecommerce_indicator.nil? && @ecommerce_indicator.to_s.length > 255
        invalid_properties.push('invalid value for "ecommerce_indicator", the character length must be smaller than or equal to 255.')
      end

      if !@effective_authentication_type.nil? && @effective_authentication_type.to_s.length > 2
        invalid_properties.push('invalid value for "effective_authentication_type", the character length must be smaller than or equal to 2.')
      end

      if !@network_score.nil? && @network_score.to_s.length > 2
        invalid_properties.push('invalid value for "network_score", the character length must be smaller than or equal to 2.')
      end

      if !@sdk_transaction_id.nil? && @sdk_transaction_id.to_s.length > 36
        invalid_properties.push('invalid value for "sdk_transaction_id", the character length must be smaller than or equal to 36.')
      end

      if !@signed_pares_status_reason.nil? && @signed_pares_status_reason.to_s.length > 2
        invalid_properties.push('invalid value for "signed_pares_status_reason", the character length must be smaller than or equal to 2.')
      end

      if !@step_up_url.nil? && @step_up_url.to_s.length > 2048
        invalid_properties.push('invalid value for "step_up_url", the character length must be smaller than or equal to 2048.')
      end

      if !@three_ds_server_transaction_id.nil? && @three_ds_server_transaction_id.to_s.length > 36
        invalid_properties.push('invalid value for "three_ds_server_transaction_id", the character length must be smaller than or equal to 36.')
      end

      if !@white_list_status_source.nil? && @white_list_status_source.to_s.length > 2
        invalid_properties.push('invalid value for "white_list_status_source", the character length must be smaller than or equal to 2.')
      end

      if !@directory_server_transaction_id.nil? && @directory_server_transaction_id.to_s.length > 36
        invalid_properties.push('invalid value for "directory_server_transaction_id", the character length must be smaller than or equal to 36.')
      end

      if !@interaction_counter.nil? && @interaction_counter.to_s.length > 2
        invalid_properties.push('invalid value for "interaction_counter", the character length must be smaller than or equal to 2.')
      end

      if !@white_list_status.nil? && @white_list_status.to_s.length > 1
        invalid_properties.push('invalid value for "white_list_status", the character length must be smaller than or equal to 1.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@acs_transaction_id.nil? && @acs_transaction_id.to_s.length > 36
      return false if !@acs_url.nil? && @acs_url.to_s.length > 2048
      return false if !@authentication_transaction_id.nil? && @authentication_transaction_id.to_s.length > 20
      return false if !@cardholder_message.nil? && @cardholder_message.to_s.length > 128
      return false if !@cavv.nil? && @cavv.to_s.length > 255
      return false if !@cavv_algorithm.nil? && @cavv_algorithm.to_s.length > 1
      return false if !@challenge_cancel_code.nil? && @challenge_cancel_code.to_s.length > 2
      return false if !@challenge_required.nil? && @challenge_required.to_s.length > 1
      return false if !@decoupled_authentication_indicator.nil? && @decoupled_authentication_indicator.to_s.length > 1
      return false if !@directory_server_error_description.nil? && @directory_server_error_description.to_s.length > 4096
      return false if !@ecommerce_indicator.nil? && @ecommerce_indicator.to_s.length > 255
      return false if !@effective_authentication_type.nil? && @effective_authentication_type.to_s.length > 2
      return false if !@network_score.nil? && @network_score.to_s.length > 2
      return false if !@sdk_transaction_id.nil? && @sdk_transaction_id.to_s.length > 36
      return false if !@signed_pares_status_reason.nil? && @signed_pares_status_reason.to_s.length > 2
      return false if !@step_up_url.nil? && @step_up_url.to_s.length > 2048
      return false if !@three_ds_server_transaction_id.nil? && @three_ds_server_transaction_id.to_s.length > 36
      return false if !@white_list_status_source.nil? && @white_list_status_source.to_s.length > 2
      return false if !@directory_server_transaction_id.nil? && @directory_server_transaction_id.to_s.length > 36
      return false if !@interaction_counter.nil? && @interaction_counter.to_s.length > 2
      return false if !@white_list_status.nil? && @white_list_status.to_s.length > 1
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] acs_transaction_id Value to be assigned
    def acs_transaction_id=(acs_transaction_id)
      if !acs_transaction_id.nil? && acs_transaction_id.to_s.length > 36
        fail ArgumentError, 'invalid value for "acs_transaction_id", the character length must be smaller than or equal to 36.'
      end

      @acs_transaction_id = acs_transaction_id
    end

    # Custom attribute writer method with validation
    # @param [Object] acs_url Value to be assigned
    def acs_url=(acs_url)
      if !acs_url.nil? && acs_url.to_s.length > 2048
        fail ArgumentError, 'invalid value for "acs_url", the character length must be smaller than or equal to 2048.'
      end

      @acs_url = acs_url
    end

    # Custom attribute writer method with validation
    # @param [Object] authentication_transaction_id Value to be assigned
    def authentication_transaction_id=(authentication_transaction_id)
      if !authentication_transaction_id.nil? && authentication_transaction_id.to_s.length > 20
        fail ArgumentError, 'invalid value for "authentication_transaction_id", the character length must be smaller than or equal to 20.'
      end

      @authentication_transaction_id = authentication_transaction_id
    end

    # Custom attribute writer method with validation
    # @param [Object] cardholder_message Value to be assigned
    def cardholder_message=(cardholder_message)
      if !cardholder_message.nil? && cardholder_message.to_s.length > 128
        fail ArgumentError, 'invalid value for "cardholder_message", the character length must be smaller than or equal to 128.'
      end

      @cardholder_message = cardholder_message
    end

    # Custom attribute writer method with validation
    # @param [Object] cavv Value to be assigned
    def cavv=(cavv)
      if !cavv.nil? && cavv.to_s.length > 255
        fail ArgumentError, 'invalid value for "cavv", the character length must be smaller than or equal to 255.'
      end

      @cavv = cavv
    end

    # Custom attribute writer method with validation
    # @param [Object] cavv_algorithm Value to be assigned
    def cavv_algorithm=(cavv_algorithm)
      if !cavv_algorithm.nil? && cavv_algorithm.to_s.length > 1
        fail ArgumentError, 'invalid value for "cavv_algorithm", the character length must be smaller than or equal to 1.'
      end

      @cavv_algorithm = cavv_algorithm
    end

    # Custom attribute writer method with validation
    # @param [Object] challenge_cancel_code Value to be assigned
    def challenge_cancel_code=(challenge_cancel_code)
      if !challenge_cancel_code.nil? && challenge_cancel_code.to_s.length > 2
        fail ArgumentError, 'invalid value for "challenge_cancel_code", the character length must be smaller than or equal to 2.'
      end

      @challenge_cancel_code = challenge_cancel_code
    end

    # Custom attribute writer method with validation
    # @param [Object] challenge_required Value to be assigned
    def challenge_required=(challenge_required)
      if !challenge_required.nil? && challenge_required.to_s.length > 1
        fail ArgumentError, 'invalid value for "challenge_required", the character length must be smaller than or equal to 1.'
      end

      @challenge_required = challenge_required
    end

    # Custom attribute writer method with validation
    # @param [Object] decoupled_authentication_indicator Value to be assigned
    def decoupled_authentication_indicator=(decoupled_authentication_indicator)
      if !decoupled_authentication_indicator.nil? && decoupled_authentication_indicator.to_s.length > 1
        fail ArgumentError, 'invalid value for "decoupled_authentication_indicator", the character length must be smaller than or equal to 1.'
      end

      @decoupled_authentication_indicator = decoupled_authentication_indicator
    end

    # Custom attribute writer method with validation
    # @param [Object] directory_server_error_description Value to be assigned
    def directory_server_error_description=(directory_server_error_description)
      if !directory_server_error_description.nil? && directory_server_error_description.to_s.length > 4096
        fail ArgumentError, 'invalid value for "directory_server_error_description", the character length must be smaller than or equal to 4096.'
      end

      @directory_server_error_description = directory_server_error_description
    end

    # Custom attribute writer method with validation
    # @param [Object] ecommerce_indicator Value to be assigned
    def ecommerce_indicator=(ecommerce_indicator)
      if !ecommerce_indicator.nil? && ecommerce_indicator.to_s.length > 255
        fail ArgumentError, 'invalid value for "ecommerce_indicator", the character length must be smaller than or equal to 255.'
      end

      @ecommerce_indicator = ecommerce_indicator
    end

    # Custom attribute writer method with validation
    # @param [Object] effective_authentication_type Value to be assigned
    def effective_authentication_type=(effective_authentication_type)
      if !effective_authentication_type.nil? && effective_authentication_type.to_s.length > 2
        fail ArgumentError, 'invalid value for "effective_authentication_type", the character length must be smaller than or equal to 2.'
      end

      @effective_authentication_type = effective_authentication_type
    end

    # Custom attribute writer method with validation
    # @param [Object] network_score Value to be assigned
    def network_score=(network_score)
      if !network_score.nil? && network_score.to_s.length > 2
        fail ArgumentError, 'invalid value for "network_score", the character length must be smaller than or equal to 2.'
      end

      @network_score = network_score
    end

    # Custom attribute writer method with validation
    # @param [Object] sdk_transaction_id Value to be assigned
    def sdk_transaction_id=(sdk_transaction_id)
      if !sdk_transaction_id.nil? && sdk_transaction_id.to_s.length > 36
        fail ArgumentError, 'invalid value for "sdk_transaction_id", the character length must be smaller than or equal to 36.'
      end

      @sdk_transaction_id = sdk_transaction_id
    end

    # Custom attribute writer method with validation
    # @param [Object] signed_pares_status_reason Value to be assigned
    def signed_pares_status_reason=(signed_pares_status_reason)
      if !signed_pares_status_reason.nil? && signed_pares_status_reason.to_s.length > 2
        fail ArgumentError, 'invalid value for "signed_pares_status_reason", the character length must be smaller than or equal to 2.'
      end

      @signed_pares_status_reason = signed_pares_status_reason
    end

    # Custom attribute writer method with validation
    # @param [Object] step_up_url Value to be assigned
    def step_up_url=(step_up_url)
      if !step_up_url.nil? && step_up_url.to_s.length > 2048
        fail ArgumentError, 'invalid value for "step_up_url", the character length must be smaller than or equal to 2048.'
      end

      @step_up_url = step_up_url
    end

    # Custom attribute writer method with validation
    # @param [Object] three_ds_server_transaction_id Value to be assigned
    def three_ds_server_transaction_id=(three_ds_server_transaction_id)
      if !three_ds_server_transaction_id.nil? && three_ds_server_transaction_id.to_s.length > 36
        fail ArgumentError, 'invalid value for "three_ds_server_transaction_id", the character length must be smaller than or equal to 36.'
      end

      @three_ds_server_transaction_id = three_ds_server_transaction_id
    end

    # Custom attribute writer method with validation
    # @param [Object] white_list_status_source Value to be assigned
    def white_list_status_source=(white_list_status_source)
      if !white_list_status_source.nil? && white_list_status_source.to_s.length > 2
        fail ArgumentError, 'invalid value for "white_list_status_source", the character length must be smaller than or equal to 2.'
      end

      @white_list_status_source = white_list_status_source
    end

    # Custom attribute writer method with validation
    # @param [Object] directory_server_transaction_id Value to be assigned
    def directory_server_transaction_id=(directory_server_transaction_id)
      if !directory_server_transaction_id.nil? && directory_server_transaction_id.to_s.length > 36
        fail ArgumentError, 'invalid value for "directory_server_transaction_id", the character length must be smaller than or equal to 36.'
      end

      @directory_server_transaction_id = directory_server_transaction_id
    end

    # Custom attribute writer method with validation
    # @param [Object] interaction_counter Value to be assigned
    def interaction_counter=(interaction_counter)
      if !interaction_counter.nil? && interaction_counter.to_s.length > 2
        fail ArgumentError, 'invalid value for "interaction_counter", the character length must be smaller than or equal to 2.'
      end

      @interaction_counter = interaction_counter
    end

    # Custom attribute writer method with validation
    # @param [Object] white_list_status Value to be assigned
    def white_list_status=(white_list_status)
      if !white_list_status.nil? && white_list_status.to_s.length > 1
        fail ArgumentError, 'invalid value for "white_list_status", the character length must be smaller than or equal to 1.'
      end

      @white_list_status = white_list_status
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          acs_rendering_type == o.acs_rendering_type &&
          acs_transaction_id == o.acs_transaction_id &&
          acs_url == o.acs_url &&
          authentication_path == o.authentication_path &&
          authorization_payload == o.authorization_payload &&
          authentication_transaction_id == o.authentication_transaction_id &&
          cardholder_message == o.cardholder_message &&
          cavv == o.cavv &&
          cavv_algorithm == o.cavv_algorithm &&
          challenge_cancel_code == o.challenge_cancel_code &&
          challenge_required == o.challenge_required &&
          decoupled_authentication_indicator == o.decoupled_authentication_indicator &&
          directory_server_error_code == o.directory_server_error_code &&
          directory_server_error_description == o.directory_server_error_description &&
          ecommerce_indicator == o.ecommerce_indicator &&
          eci == o.eci &&
          eci_raw == o.eci_raw &&
          effective_authentication_type == o.effective_authentication_type &&
          ivr == o.ivr &&
          network_score == o.network_score &&
          pareq == o.pareq &&
          pares_status == o.pares_status &&
          proof_xml == o.proof_xml &&
          proxy_pan == o.proxy_pan &&
          sdk_transaction_id == o.sdk_transaction_id &&
          signed_pares_status_reason == o.signed_pares_status_reason &&
          specification_version == o.specification_version &&
          step_up_url == o.step_up_url &&
          three_ds_server_transaction_id == o.three_ds_server_transaction_id &&
          ucaf_authentication_data == o.ucaf_authentication_data &&
          ucaf_collection_indicator == o.ucaf_collection_indicator &&
          veres_enrolled == o.veres_enrolled &&
          white_list_status_source == o.white_list_status_source &&
          xid == o.xid &&
          directory_server_transaction_id == o.directory_server_transaction_id &&
          authentication_result == o.authentication_result &&
          authentication_status_msg == o.authentication_status_msg &&
          indicator == o.indicator &&
          interaction_counter == o.interaction_counter &&
          white_list_status == o.white_list_status
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [acs_rendering_type, acs_transaction_id, acs_url, authentication_path, authorization_payload, authentication_transaction_id, cardholder_message, cavv, cavv_algorithm, challenge_cancel_code, challenge_required, decoupled_authentication_indicator, directory_server_error_code, directory_server_error_description, ecommerce_indicator, eci, eci_raw, effective_authentication_type, ivr, network_score, pareq, pares_status, proof_xml, proxy_pan, sdk_transaction_id, signed_pares_status_reason, specification_version, step_up_url, three_ds_server_transaction_id, ucaf_authentication_data, ucaf_collection_indicator, veres_enrolled, white_list_status_source, xid, directory_server_transaction_id, authentication_result, authentication_status_msg, indicator, interaction_counter, white_list_status].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = CyberSource.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
